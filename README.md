# Shiny SQL: Integration of R Shiny and SQL for scalable database visualization

Authors: Noah Baker, Andrew Nguyen
UC Berkeley, PH290: Biostatistical Computing

## Project Aims & Motivations
The rapid increase in the quantity and complexity of data limits its use and exploration to those with programming knowledge. The requirement for coding expertise reduces accessibility to those where the data is most relevant; policymakers, administrators, or practitioners. Decreasing barriers in data exploration and analysis will allow new perspectives and interpretations from domain experts.

Current offerings and solutions are inaccessible, expensive, or inefficient – statistical software like Python, R, and Julia are freely available but would likely require a biostatistician or data analysis (of which not all health entities may have access to); more user-friendly solutions like SAS, Stata, and Tableau for visualization post analysis are expensive and still have a learning barrier; traditional spreadsheet and visualization software like Excel become clunkier with larger datasets and have limited tools for procedural and reproducible data extraction, cleaning, and display.

To address this gap, we developed a prototype database access and viewing tool using R Shiny and SQL; we demonstrated its usage with the MIMIC-III database. R’s flexible support for interactivity and visualization, coupled with SQL’s performance advantages for large datasets allows for rapid manipulation of large and complex datasets with no knowledge of coding. The Shiny application will allow any individual to investigate potential relationships within these data and it should be scalable to other similar large relational databases. 

## Methodology
Our Shiny application utilizes a standard UI and Server layout to collect user inputs and query, process, and visualize. The application pulls all tables from the database and upon the user’s choice of the first table, will provide corresponding tables with shared variables to join upon. The user interface contains a list of dependent uiOutput elements which appear sequentially as the user completes query questions. The dependent nature of these UI elements prevents errors from occurring when values, calculated for user selections, are missing upstream. Small queries, returning one line from the table(s) selected, quickly returns available variables and types to the user. Once a user selects the table(s) they are interested in investigating, a small SQL query reads the column names from the merged data, selecting for numerical and categorical variables, and returns these as options for the variable to visualize. Once the visualization variable is selected, a radio button for the option to perform a synonymous SQL GROUP BY appears. If the user requests to GROUP BY, a conditional small query returns all of the categorical variables available in the selected table(s). If the user chooses not to GROUP BY and if the user selects a numerical variable to visualize, a radio button for the option to visualize a second variable appears. If the user requests a second variable, a conditional small query returns all of the available numerical variables for selection. Once a full SQL query is built, the option for naming the output figure appears to the user and a Run Query button appears. 

Running the query is read as an observeEvent of the Run Query button, beginning the full SQL query. Isolated variables inside the plotting output takes a snapshot of the value for the query. Plot outputs are determined by logic gates based on the variable type(s) selected for visualization and/or grouping: a categorical variable only is visualized as counts of each category in a bar plot; a categorical variable with a GROUP BY is visualized as a multicolored, grouped category count bar plot; a numerical variable only is visualized as a histogram with a kernel density plot; a numerical variable with a GROUP BY is visualized as a multicolored, grouped violin plot with a boxplot overlay; a numerical variable with a second numerical variable is visualized as a scatter plot. Whenever a SQL query reselection is made in the UI, the current plot clears and the UI logic resets the conditional variable sequence of appearance. 

## Discussion

The application building process was an exercise in the end-to-end development process. Throughout said process, it became increasingly clearer the value of thoughtful and pre-programming prototyping and UI/UX research; since this application had a front-end meant for users who may not have a programming background, it was imperative to produce points of input that were succinct and accessible but also provided outputs that were amenable to the application backend. 

For example, it was an involved learning experience to find an elegant solution to reactively defining shared variables between two tables within a database to even know which tables were joinable, and then to discover the class/variable type of each variable to know how to direct the application to plotting the data once pulled. There are solutions to accessing tables and table fields within the DBI library, but we resorted to roundabout measures (making a small query dataset to dictate fields instead of directly pulling fields) to make sure we preserved compatibility to R comparison operators. 

All of which is to say – it was a useful exercise in understanding how we could better approach future application developments (whether it be in an academic or professional setting), and the value of UI/UX knowledge combined with a working knowledge of whichever programming language the application is written in. 

## Limitations & Further Development

At the time of writing, our application is still limited to simpler SQL operations (we have not yet built in aggregators at the SQL level) – this is an area that we would like to explore further; to performance test SQL aggregation versus aggregation in R post-SQL pull to determine the most efficient pathway for more advanced data aggregation. 
